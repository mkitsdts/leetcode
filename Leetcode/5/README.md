# Leetcode 5
给你一个字符串s,找到s中最长的回文子串。

示例 1：
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。

示例 2：
输入：s = "cbbd"
输出："bb"
 
提示：
1 <= s.length <= 1000
s 仅由数字和英文字母组成
--------------------------------------
二话不说暴力搜索。运行时间七百多ms，拿下。时间复杂度O(n^3)我很满意，根本不需要优化？
反了，这么多重复运算，试试用动态规划吧。
先确定状态转移方程，注意到一个回文字符串有两点必要条件，一是字符串两端字母相等，二是除去首位两端的字符串是回文。我们假设P[i,j]表示字符串里下标i到下标j的子字符串状态，容易得到P[i,j] = (P[i+1,j-1] && s[i] == s[j]), 列出状态转移方程接下来就确定初始条件。
字符串可能由奇数个字符组成，也可能由偶数个字符组成。所以我们得先确定奇数个字符和偶数个字符对应的初始状态，对于任意一个字符都是回文，也就是P[i,i]=1,对于两个字符组成的字符串我们也是很好判断的，P[i,i+1] = s[i] == s[i+1]。我们先处理好这两个初始状态，然后根据初始状态进行计算就可以解决问题了。很好理解的方法，不过时间复杂度只能优化到O(n^2)。
真的想不到怎么优化到O(n)了。所以去看答案吧。