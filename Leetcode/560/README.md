# Leetcode 560
给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。
子数组是数组中元素的连续非空序列。
示例 1：
输入：nums = [1,1,1], k = 2
输出：2
示例 2：
输入：nums = [1,2,3], k = 3
输出：2
提示：
1 <= nums.length <= 2 * 10^4
-1000 <= nums[i] <= 1000
-10^7 <= k <= 10^7
----------------------------------------------
最容易想到的暴力枚举在这道题上是可以通过的，所以就没必要再记录了（）
O(n^2)复杂度还是不够的，得想办法优化一下。
我想到的是把全部数的和先算出来，然后再从头开始一个数一个数减去。这想法只能说接近官方题解，还有一些不成熟的地方，比如说没有想到把算的过程中得到的值存储起来，答案就等于从这些值里差为k里面的个数，这个是我没有想到的。然后实际写出来的代码依然是O(n^2)，只是常数级别的优化
一怒之下就去看了题解，发现这里可以用到unordered_map存储，每次只需要寻找求出来的和减去k是否存在过，如果存在，则加上存在的次数，不存在则继续往下算，这样只需要O(n)的时间复杂度，但同时也多了O(n)的空间复杂度。这还是值得的。
原来这个叫前缀和问题，记录了。